/*
Input format: Line segments generated by Mathematica (e.g., "For[i = 0, i < 30, i++, Print[table = Table[{Line[RandomReal[1, {2, 2}]]}, {6}]];Print["b"]; Print[Graphics[table]]]" ).
Added 'b' as seperator.
Can copy the test file as cin for online c++ compiler (onlinegdb, etc). Or read as a file on local machine.
Output: The two line segments that are found to intersect. If there's no intersect, it displays the message "No intersect".
*/

#include<iostream>
#include<fstream>
#include<set>
#include<string>
#include<vector>
#include<algorithm>
#include<cfloat>
using namespace std;
struct segment;
struct point{
    double x=DBL_MIN;
    int e=0;
    double y=DBL_MIN;
    segment* seg=nullptr;
    point operator-(const point &p2){
        point p;
        p.x=x-p2.x;
        p.y=y-p2.y;
        return p;
    }
    point operator+(const point &p2){
        point p;
        p.x=x+p2.x;
        p.y=y+p2.y;
        return p;
    }
    double operator*(const point &p2){
        return (x*p2.y-p2.x*y);
    }
};
struct segment{
    point p1;
    point p2;
};
double direction(point pi,point pj,point pk){
    return (pk-pi)*(pj-pi);
}
bool on_seg(point pi,point pj,point pk){
    if(min(pi.x,pj.x)<=pk.x&&pk.x<=max(pi.x,pj.x)&&min(pi.y,pj.y)<=pk.y&&pk.y<=max(pi.y,pj.y)) return true;
    return false;
}
bool seg_intersect(segment a, segment b){
    point p1=a.p1;point p2=a.p2;point p3=b.p1;point p4=b.p2;
    double d1=direction(p3,p4,p1);
    double d2=direction(p3,p4,p2);
    double d3=direction(p1,p2,p3);
    double d4=direction(p1,p2,p4);
    if(d1*d2<0&&d3*d4<0) return true;
    else if(d1==0&&on_seg(p3,p4,p1)) return true;
    else if(d2==0&&on_seg(p3,p4,p2)) return true;
    else if(d3==0&&on_seg(p1,p2,p3)) return true;
    else if(d4==0&&on_seg(p1,p2,p4)) return true;
    else return false;
}
void display(const vector<segment> &s){
    for(int i=0;i<s.size();i++){
        cout<<"{{"<<s[i].p1.x<<','<<s[i].p1.y<<"},{"<<s[i].p2.x<<','<<s[i].p2.y<<"}} ";
    }
}
void display(const segment &s){
    cout<<"{"<<s.p1.x<<","<<s.p1.y<<"},{"<<s.p2.x<<','<<s.p2.y<<"}\n";
}
vector<vector<segment>> read_input(istream &is){
    char t;
    double x1,y1,x2,y2;
    segment k;
    vector<segment> s;
    vector<vector<segment>> r;
    //int count=0;
    while(is>>t){
        //if(count>100000) break;
        //count++;
        while(t!='['&&t!='b') {is>>t;}
        if(t=='b'){
            r.push_back(s);
            s.clear();
            continue;
        }
        is>>t;
        is>>t;
        is>>x1>>t>>y1>>t>>t>>t>>x2>>t>>y2;
        k.p1.x=x1;k.p1.y=y1;k.p2.x=x2;k.p2.y=y2;
        s.push_back(k);
    }
    return r;
}
bool seg_sort (segment a,segment b) {//make sure p1.x<p2.x in both a and b
    if(a.p1.x<b.p1.x) return true;
    else if(a.p1.x==b.p1.x){
        if(a.p2.x<b.p2.x) return true;
        else if(a.p1.x==b.p2.x){
            if(a.p1.y<b.p2.y) return true;
            else return false;
        }
        else return false;
    }
    else return false;
}
bool p_sort (point a,point b) {
    if(a.x<b.x) return true;
    else if(a.x==b.x){
        if(a.e<b.e) return true;
        else if(a.e==b.e){
            if(a.y<b.y) return true;
            else return false;
        }
        else return false;
    }
    else return false;
}
auto cmp=[](segment a,segment b){
    if(a.p1.x<b.p1.x) return direction(a.p1,b.p1,a.p2)>0;
    return direction(b.p1,a.p1,b.p2)<0;
};
struct cmp{
    bool operator()(segment a,segment b) const {
        return direction(b.p1,a.p1,b.p2)<0;
    }
};
void display(const set<segment,decltype(cmp)> &T){
    auto it=T.begin();
    while(it!=T.end()){
        display(*it);
        it++;
    }
    return;
}
bool compare(const segment a, segment b){
    if(a.p1.x==b.p1.x&&a.p1.y==b.p1.y&&a.p2.x==b.p2.x&&a.p2.y==b.p2.y) return true;
    else return false;
}
const segment* above(set<segment,decltype(cmp)> &T,segment s){
    auto it=T.find(s);
    if(it==T.end()) return nullptr;
    //cout<<"above->found s:";
    //display(*it);
    if(it==T.begin()) return nullptr;
    --it;
    //cout<<"above->";
    //display(*it);
    return &(*it);
}
const segment* below(set<segment,decltype(cmp)> &T,segment s){
    auto it=T.find(s);
    if(it==T.end()) return nullptr;
    //cout<<"below->found s:";
    //display(*it);
    ++it;
    if(it==T.end()) return nullptr;
    //cout<<"below->";
    //display(*it);
    return &(*it);
}
pair<segment,segment> intersect(vector<segment> &input){
    point z;
    segment g={z,z};
    pair<segment,segment> r=make_pair(g,g);
    for(int i=0;i<input.size();i++){//p1 must be to the left of p2
        if(input[i].p1.x>input[i].p2.x){
            point temp=input[i].p1;
            input[i].p1=input[i].p2;
            input[i].p2=temp;
        }
        input[i].p2.e=1;
        input[i].p1.seg=input[i].p2.seg=&input[i];
    }
    vector<point> points;
    for(int i=0;i<input.size();i++){
        points.push_back(input[i].p1);
        points.push_back(input[i].p2);
    }
    sort(points.begin(),points.end(),p_sort);
    
    set<segment,decltype(cmp)> T(cmp);
    for(int p=0;p<points.size();p++){
        //cout<<"--------------------\nT is:";display(T);cout<<endl;
        segment s=*(points[p].seg);
        //cout<<"s=";
        //display(s);
        //cout<<"e is:"<<points[p].e<<endl;
        const segment* ab;
        const segment* be;
        if(points[p].e==0){
            auto test=T.insert(s);
            if(ab=above(T,s)){
                //cout<<"ab->{"<<(*ab).p1.x<<','<<(*ab).p1.y<<"},{"<<(*ab).p2.x<<","<<(*ab).p2.y<<"}\n";
                if(seg_intersect(*ab,s)){
                    return make_pair(*ab,s);
                }
            }
            if(be=below(T,s)){
                //cout<<"be->{"<<(*be).p1.x<<','<<(*be).p1.y<<"},{"<<(*be).p2.x<<","<<(*be).p2.y<<"}\n";
                if(seg_intersect(*be,s)){
                    return make_pair(*be,s);
                }
            }
        }
        else{
            if(ab=above(T,s)){
                if(be=below(T,s)){
                    if(seg_intersect(*ab,*be)) return make_pair(*ab,*be);
                }
            }
            T.erase(s);
        }
    }
    return r;
}
void math_display(vector<segment> seg){
    cout<<"Graphics[{";
    for(int i=0;i<seg.size();i++){
        cout<<"{Line[{{"<<seg[i].p1.x<<','<<seg[i].p1.y<<"},{"<<seg[i].p2.x<<','<<seg[i].p2.y<<"}}]},";
    }
    cout<<"}]\n";
}
int main(){
    vector<vector<segment>> segments=read_input(cin);
    /*pair<segment,segment> res0=intersect(segments[4]);
    //math_display(segments[4]);
    //cout<<"{"<<res0.first.p1.x<<","<<res0.first.p1.y<<"},{"<<res0.first.p2.x<<","<<res0.first.p2.y<<"} <-> {"<<res0.second.p1.x<<","<<res0.second.p1.y<<"},{"<<res0.second.p2.x<<","<<res0.second.p2.y<<"}\n";
    //display(segments[0]);
    for(int i=0;i<segments.size();i++){
        display(segments[i]);
        cout<<endl;
    }*/
    vector<pair<segment,segment>> result;
    for(int i=0;i<segments.size();i++){
        result.push_back(intersect(segments[i]));
    }
    for(int i=0;i<result.size();i++){
        if(result[i].first.p1.x==DBL_MIN){cout<<"No intersect\n*****************************\n";continue;}
        cout<<"{"<<result[i].first.p1.x<<","<<result[i].first.p1.y<<"},{"<<result[i].first.p2.x<<","<<result[i].first.p2.y<<"} <-> {"<<result[i].second.p1.x<<","<<result[i].second.p1.y<<"},{"<<result[i].second.p2.x<<","<<result[i].second.p2.y<<"}\n";
        cout<<"*****************************"<<endl;
    }
    return 0;
}
